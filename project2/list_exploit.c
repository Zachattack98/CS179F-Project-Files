#include <stdio.h>
#include <unistd.h>
void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.
        syscall(326, 0, NULL);
    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
    //     For example:
    //     (gdb) print (int)&((struct thread_info*)0)->task
    //     will gives you the offset between struct thread_info and  thread_info->task
    //     
    //          thread_info -> task = 0
    //          task_struct -> cred = 1456
    //          cred -> uid = 4
    //          cred -> euid = 20
    //
    // 2. Then you can make use of arbitrary read to get the address of struct task.
    
    
    // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.

    // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege
    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"euid = %d\n",geteuid());
    // The exploit itself
    runExploit();

    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid = %d\n",geteuid());

    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
